//
//
// ==============================================
//     -  Створити функцію конструктор для об'єкту який описує теги
// Властивості
// -назва тегу
// - опис його дій
// - масив з атрибутами (2-3 атрибути максимум)
// Кожен атрибут описати як окремий який буде містити
// -назву атрибуту
// -опис дії атрибуту
// інформацію брати з htmlbook.ru
//
// Таким чином описати теги
// -a
// -div
// -h1
// -span
// -input
// -form
// -option
// -select
// Приклад результату
// {
//     titleOfTag: 'area',
//         action: `Каждый элемент <area> определяет активные области изображения, которые являются ссылками...`,
//     attrs: [
//     {titleOfAttr: 'accesskey', actionOfAttr: 'Переход к области с помощью комбинации клавиш'},
//     {/*some props and values*/},
//     {/*...*/},
//     {/*...*/},
// ]
//
// }
// ==============================================

// function ElementsHtml(titleOfTag, action, attrs = []) {
//     this.titleOfTag = titleOfTag;
//     this.action = action;
//     this.attrs = attrs;
//     this.addAttrs = function (titleOfAttr, actionOfAttr) {
//         this.attrs.push({titleOfAttr, actionOfAttr});
//     }
//
// }

// let a = new ElementsHtml('a', 'Тег <a> является одним из важных элементов HTML и предназначен для создания ссылок. ' +
//     'В зависимости от присутствия атрибутов name или href тег <a> устанавливает ссылку или якорь. Якорем называется закладка внутри страницы, ' +
//     'которую можно указать в качестве цели ссылки. При использовании ссылки, которая указывает на якорь, происходит переход к закладке ' +
//     'внутри веб-страницы.');
//
// a.addAttrs('accessKey', 'Активация ссылки с помощью комбинации клавиш.\n');
// a.addAttrs('coords', 'Устанавливает координаты активной области.\n');
// a.addAttrs('download', 'Предлагает скачать указанный по ссылке файл.\n');
//
// console.log(a);
//
// let div = new ElementsHtml('div', 'Элемент <div> является блочным элементом и предназначен для выделения фрагмента документа с целью изменения вида содержимого. Как правило, вид блока управляется с помощью стилей. Чтобы не описывать каждый раз стиль внутри тега, можно выделить стиль во внешнюю таблицу стилей, а для тега добавить атрибут class или id с именем селектора.\n' +
//     '\n');
// div.addAttrs('align', 'Задает выравнивание содержимого тега <div>.\n');
// div.addAttrs('title', 'Добавляет всплывающую подсказку к содержимому.\n');
//
// console.log(div);
//
// let h1 = new ElementsHtml('h1', 'HTML предлагает шесть заголовков разного уровня, которые показывают относительную важность секции, расположенной после заголовка. Так, тег <h1> представляет собой наиболее важный заголовок первого уровня, а тег <h6> служит для обозначения заголовка шестого уровня и является наименее значительным. По умолчанию, заголовок первого уровня отображается самым крупным шрифтом жирного начертания, заголовки последующего уровня по размеру меньше. Теги <h1>,...,<h6> относятся к блочным элементам, они всегда начинаются с новой строки, а после них другие элементы отображаются на следующей строке. Кроме того, перед заголовком и после него добавляется пустое пространство.\n' +
//     '\n');
// h1.addAttrs('align', 'Определяет выравнивание заголовка.\n');
//
// console.log(h1);
//
// let span = new ElementsHtml('span', 'Тег <span> предназначен для определения строчных элементов документа. В отличие от блочных элементов, таких как <table>, <p> или <div>, с помощью тега <span> можно выделить часть информации внутри других тегов и установить для нее свой стиль. Например, внутри абзаца (тега <p>) можно изменить цвет и размер первой буквы, если добавить начальный и конечный тег <span> и определить для него стиль текста. Чтобы не описывать каждый раз стиль внутри тега, можно выделить стиль во внешнюю таблицу стилей, а для тега добавить атрибут class или id с именем селектора.\n' +
//     '\n');
//
// console.log(span);
//
// let input = new ElementsHtml('input', 'Тег <input> является одним из разносторонних элементов формы и позволяет создавать разные элементы интерфейса и обеспечить взаимодействие с пользователем. Главным образом <input> предназначен для создания текстовых полей, различных кнопок, переключателей и флажков. Хотя элемент <input> не требуется помещать внутрь контейнера <form>, определяющего форму, но если введенные пользователем данные должны быть отправлены на сервер, где их обрабатывает серверная программа, то указывать <form> обязательно. То же самое обстоит и в случае обработки данных с помощью клиентских приложений, например, скриптов на языке JavaScript.\n' +
//     '\n');
// input.addAttrs('accept', 'Устанавливает фильтр на типы файлов, которые вы можете отправить через поле загрузки файлов.\n');
// input.addAttrs('accesskey', 'Переход к элементу с помощью комбинации клавиш.\n');
// input.addAttrs('align', 'Определяет выравнивание изображения.\n');
//
// console.log(input);
//
// let form = new ElementsHtml('form', 'Тег <form> устанавливает форму на веб-странице. Форма предназначена для обмена данными между пользователем и сервером. Область применения форм не ограничена отправкой данных на сервер, с помощью клиентских скриптов можно получить доступ к любому элементу формы, изменять его и применять по своему усмотрению.\n' +
//     '\n')
// form.addAttrs('accept-charset', 'Устанавливает кодировку, в которой сервер может принимать и обрабатывать данные.\n');
// form.addAttrs('action', 'Адрес программы или документа, который обрабатывает данные формы.\n');
// form.addAttrs('autocomplete', 'Включает автозаполнение полей формы.\n');
//
// console.log(form);
//
// let option = new ElementsHtml('option', 'Тег <option> определяет отдельные пункты списка, создаваемого с помощью контейнера <select>. Ширина списка определяется самым широким текстом, указанным в теге <option>, а также может изменяться с помощью стилей. Если планируется отправлять данные списка на сервер, то требуется поместить элемент <select> внутрь формы. Это также необходимо, когда к данным списка идет обращение через скрипты.\n' +
//     '\n');
// option.addAttrs('disabled', 'Заблокировать для доступа элемент списка.\n');
// option.addAttrs('label', 'Указание метки пункта списка.\n');
// option.addAttrs('selected', 'Заранее устанавливает определенный пункт списка выделенным.\n');
//
// console.log(option);
//
// let select = new ElementsHtml('select', 'Тег <select> позволяет создать элемент интерфейса в виде раскрывающегося списка, а также список с одним или множественным выбором, как показано далее. Конечный вид зависит от использования атрибута size тега <select>, который устанавливает высоту списка. Ширина списка определяется самым широким текстом, указанным в теге <option>, а также может изменяться с помощью стилей. Каждый пункт создается с помощью тега <option>, который должен быть вложен в контейнер <select>. Если планируется отправлять данные списка на сервер, то требуется поместить элемент <select> внутрь формы. Это также необходимо, когда к данным списка идет обращение через скрипты.\n' +
//     '\n');
// select.addAttrs('accesskey', 'Позволяет перейти к списку с помощью некоторого сочетания клавиш.\n');
// select.addAttrs('autofocus', 'Устанавливает, что список получает фокус после загрузки страницы.\n');
// select.addAttrs('disabled', 'Блокирует доступ и изменение элемента.\n');
//
// console.log(select);

// ==============================================
//     -  Створити класс  для об'єкту який описує теги
// Властивості
// -назва тегу
// - опис його дій
// - масив з атрибутами (2-3 атрибути максимум)
// Кожен атрибут описати як окремий який буде містити
// -назву атрибуту
// -опис дії атрибуту
// інформацію брати з htmlbook.ru
//
// Таким чином описати теги
// -a
// -div
// -h1
// -span
// -input
// -form
// -option
// -select
// Приклад результату
// {
//     titleOfTag: 'area',
//         action: `Каждый элемент <area> определяет активные области изображения, которые являются ссылками...`,
//     attrs: [
//     {titleOfAttr: 'accesskey', actionOfAttr: 'Переход к области с помощью комбинации клавиш'},
//     {/*some props and values*/},
//     {/*...*/},
//     {/*...*/},
// ]
//
// }
// ==============================================

// class ElementsHTMLClass {
//     constructor(titleOfTag, action, attrs = []) {
//         this.titleOfTag = titleOfTag;
//         this.action = action;
//         this.attrs = attrs;
//         this.addAttrs2 = function (titleOfAttr, actionOfAttr) {
//             this.attrs.push({titleOfAttr, actionOfAttr});
//         }
//     }
// }
//
// let aClass = new ElementsHTMLClass('a', 'Тег <a> является одним из важных элементов HTML и предназначен для создания ссылок. ' +
//     'В зависимости от присутствия атрибутов name или href тег <a> устанавливает ссылку или якорь. Якорем называется закладка внутри страницы, ' +
//     'которую можно указать в качестве цели ссылки. При использовании ссылки, которая указывает на якорь, происходит переход к закладке ' +
//     'внутри веб-страницы.');
//
// aClass.addAttrs2('accessKey', 'Активация ссылки с помощью комбинации клавиш.\n');
// aClass.addAttrs2('coords', 'Устанавливает координаты активной области.\n');
// aClass.addAttrs2('download', 'Предлагает скачать указанный по ссылке файл.\n');
//
// console.log(aClass);
//
// let div2 = new ElementsHTMLClass('div', 'Элемент <div> является блочным элементом и предназначен для выделения фрагмента документа с целью изменения вида содержимого. Как правило, вид блока управляется с помощью стилей. Чтобы не описывать каждый раз стиль внутри тега, можно выделить стиль во внешнюю таблицу стилей, а для тега добавить атрибут class или id с именем селектора.\n' +
//     '\n');
// div2.addAttrs2('align', 'Задает выравнивание содержимого тега <div>.\n');
// div2.addAttrs2('title', 'Добавляет всплывающую подсказку к содержимому.\n');
//
// console.log(div2);
//
// let h12 = new ElementsHTMLClass('h1', 'HTML предлагает шесть заголовков разного уровня, которые показывают относительную важность секции, расположенной после заголовка. Так, тег <h1> представляет собой наиболее важный заголовок первого уровня, а тег <h6> служит для обозначения заголовка шестого уровня и является наименее значительным. По умолчанию, заголовок первого уровня отображается самым крупным шрифтом жирного начертания, заголовки последующего уровня по размеру меньше. Теги <h1>,...,<h6> относятся к блочным элементам, они всегда начинаются с новой строки, а после них другие элементы отображаются на следующей строке. Кроме того, перед заголовком и после него добавляется пустое пространство.\n' +
//     '\n');
// h12.addAttrs2('align', 'Определяет выравнивание заголовка.\n');
//
// console.log(h12);
//
// let span2 = new ElementsHTMLClass('span', 'Тег <span> предназначен для определения строчных элементов документа. В отличие от блочных элементов, таких как <table>, <p> или <div>, с помощью тега <span> можно выделить часть информации внутри других тегов и установить для нее свой стиль. Например, внутри абзаца (тега <p>) можно изменить цвет и размер первой буквы, если добавить начальный и конечный тег <span> и определить для него стиль текста. Чтобы не описывать каждый раз стиль внутри тега, можно выделить стиль во внешнюю таблицу стилей, а для тега добавить атрибут class или id с именем селектора.\n' +
//     '\n');
//
// console.log(span2);
//
// let input2 = new ElementsHTMLClass('input', 'Тег <input> является одним из разносторонних элементов формы и позволяет создавать разные элементы интерфейса и обеспечить взаимодействие с пользователем. Главным образом <input> предназначен для создания текстовых полей, различных кнопок, переключателей и флажков. Хотя элемент <input> не требуется помещать внутрь контейнера <form>, определяющего форму, но если введенные пользователем данные должны быть отправлены на сервер, где их обрабатывает серверная программа, то указывать <form> обязательно. То же самое обстоит и в случае обработки данных с помощью клиентских приложений, например, скриптов на языке JavaScript.\n' +
//     '\n');
// input2.addAttrs2('accept', 'Устанавливает фильтр на типы файлов, которые вы можете отправить через поле загрузки файлов.\n');
// input2.addAttrs2('accesskey', 'Переход к элементу с помощью комбинации клавиш.\n');
// input2.addAttrs2('align', 'Определяет выравнивание изображения.\n');
//
// console.log(input2);
//
// let form2 = new ElementsHTMLClass('form', 'Тег <form> устанавливает форму на веб-странице. Форма предназначена для обмена данными между пользователем и сервером. Область применения форм не ограничена отправкой данных на сервер, с помощью клиентских скриптов можно получить доступ к любому элементу формы, изменять его и применять по своему усмотрению.\n' +
//     '\n')
// form2.addAttrs2('accept-charset', 'Устанавливает кодировку, в которой сервер может принимать и обрабатывать данные.\n');
// form2.addAttrs2('action', 'Адрес программы или документа, который обрабатывает данные формы.\n');
// form2.addAttrs2('autocomplete', 'Включает автозаполнение полей формы.\n');
//
// console.log(form2);
//
// let option2 = new ElementsHTMLClass('option', 'Тег <option> определяет отдельные пункты списка, создаваемого с помощью контейнера <select>. Ширина списка определяется самым широким текстом, указанным в теге <option>, а также может изменяться с помощью стилей. Если планируется отправлять данные списка на сервер, то требуется поместить элемент <select> внутрь формы. Это также необходимо, когда к данным списка идет обращение через скрипты.\n' +
//     '\n');
// option2.addAttrs2('disabled', 'Заблокировать для доступа элемент списка.\n');
// option2.addAttrs2('label', 'Указание метки пункта списка.\n');
// option2.addAttrs2('selected', 'Заранее устанавливает определенный пункт списка выделенным.\n');
//
// console.log(option2);
//
// let select2 = new ElementsHTMLClass('select', 'Тег <select> позволяет создать элемент интерфейса в виде раскрывающегося списка, а также список с одним или множественным выбором, как показано далее. Конечный вид зависит от использования атрибута size тега <select>, который устанавливает высоту списка. Ширина списка определяется самым широким текстом, указанным в теге <option>, а также может изменяться с помощью стилей. Каждый пункт создается с помощью тега <option>, который должен быть вложен в контейнер <select>. Если планируется отправлять данные списка на сервер, то требуется поместить элемент <select> внутрь формы. Это также необходимо, когда к данным списка идет обращение через скрипты.\n' +
//     '\n');
// select2.addAttrs2('accesskey', 'Позволяет перейти к списку с помощью некоторого сочетания клавиш.\n');
// select2.addAttrs2('autofocus', 'Устанавливает, что список получает фокус после загрузки страницы.\n');
// select2.addAttrs2('disabled', 'Блокирует доступ и изменение элемента.\n');
//
// console.log(select2);

// ==============================================
//     - Створити об'єкт car, з властивостями модель, виробник, рік випуску, максимальна швидкість, об'єм двигуна. додати в об'єкт функції:
// -- drive () - яка виводить в консоль "їдемо зі швидкістю {максимальна швидкість} на годину"
// -- info () - яка виводить всю інформацію про автомобіль
// -- increaseMaxSpeed (newSpeed) - яка підвищує значення максимальної швидкості на значення newSpeed
// -- changeYear (newValue) - змінює рік випуску на значення newValue
// -- addDriver (driver) - приймає об'єкт який "водій" з довільним набором полів, і доавляет його в поточний об'єкт car
// ==============================================

// let car = {
//     model: 'A8',
//     producer: 'Audi',
//     year: '2012',
//     maxSpeed: 250,
//     engine: 4000,
//     drive() {
//         console.log(`Їдемо зі швидкістю ${this.maxSpeed} на годину`)
//     },
//     info() {
//         console.log(`Модель ${this.model}, виробник ${this.producer}, ${this.year} року випуску з двигуном об'ємом ${this.engine} см/3 розганяється до ${this.maxSpeed} кілометрів на годину`);
//     },
//     increaseMaxSpeed(newSpeed) {
//         this.maxSpeed += newSpeed;
//         return newSpeed
//     },
//     changeYear(newValue) {
//         this.year = newValue;
//         return this.year
//     },
//     addDriver(driver) {
//         car.driver = driver
//     }
// }
//
// car.addDriver({name: 'stepan', age: 24});
// console.log(car);

// ==============================================
//     - Створити функцію конструктор яка дозволяє створювати об'єкти car, з властивостями модель, виробник, рік випуску, максимальна швидкість, об'єм двигуна. додати в об'єкт функції:
// -- drive () - яка виводить в консоль "їдемо зі швидкістю {максимальна швидкість} на годину"
// -- info () - яка виводить всю інформацію про автомобіль
// -- increaseMaxSpeed (newSpeed) - яка підвищує значення максимальної швидкості на значення newSpeed
// -- changeYear (newValue) - змінює рік випуску на значення newValue
// -- addDriver (driver) - приймає об'єкт який "водій" з довільним набором полів, і доавляет його в поточний об'єкт car
// ==============================================

// function Car(model, producer, year, maxSpeed, engine) {
//     this.model = model;
//     this.producer = producer;
//     this.year = year;
//     this.maxSpeed = maxSpeed;
//     this.engine = engine;
//     this.drive = function() {
//         console.log(`Їдемо зі швидкістю ${this.maxSpeed} на годину`)
//     }
//     this.info = function() {
//         console.log(`Модель ${this.model}, виробник ${this.producer}, ${this.year} року випуску з двигуном об'ємом ${this.engine} см/3 розганяється до ${this.maxSpeed} кілометрів на годину`);
//     }
//     this.increaseMaxSpeed = function(newSpeed) {
//         this.maxSpeed += newSpeed;
//         return newSpeed
//     }
//     this.changeYear = function(newValue) {
//         this.year = newValue;
//         return this.year
//     }
//     this.addDriver = function(driver) {
//         this.driver = driver
//     }
// }

// ==============================================
//     - Створити клас який дозволяє створювати об'єкти car, з властивостями модель, виробник, рік випуску, максимальна швидкість, об'єм двигуна. додати в об'єкт функції:
// -- drive () - яка виводить в консоль "їдемо зі швидкістю {максимальна швидкість} на годину"
// -- info () - яка виводить всю інформацію про автомобіль
// -- increaseMaxSpeed (newSpeed) - яка підвищує значення максимальної швидкості на значення newSpeed
// -- changeYear (newValue) - змінює рік випуску на значення newValue
// -- addDriver (driver) - приймає об'єкт який "водій" з довільним набором полів, і доавляет його в поточний об'єкт car
// ==============================================

// class Car {
//     constructor (model, producer, year, maxSpeed, engine) {
//
//         this.model = model;
//         this.producer = producer;
//         this.year = year;
//         this.maxSpeed = maxSpeed;
//         this.engine = engine;
//     }
//     drive() {
//         console.log(`Їдемо зі швидкістю ${this.maxSpeed} на годину`)
//     }
//     info() {
//         console.log(`Модель ${this.model}, виробник ${this.producer}, ${this.year} року випуску з двигуном об'ємом ${this.engine} см/3 розганяється до ${this.maxSpeed} кілометрів на годину`);
//     }
//     increaseMaxSpeed(newSpeed) {
//         this.maxSpeed += newSpeed;
//         return newSpeed
//     }
//     changeYear(newValue) {
//         this.year = newValue;
//         return this.year
//     }
//     addDriver(driver) {
//         this.driver = driver
//     }
// }

//
// ==============================================
//     -створити класс попелюшка з полями ім'я, вік, розмір ноги
// --Створити 10 попелюшок , покласти їх в масив
// --Сторити об'єкт класу "принц" за допомоги класу який має поля ім'я, вік, туфелька яку він знайшов.
// -- за допоиоги циклу знайти яка попелюшка повинна бути з принцом
// ==============================================

// class Cinderella {
//     constructor(name, age, footSize) {
//         this.name = name;
//         this.age = age;
//         this.size = footSize;
//     }
// }
//
// let anna = new Cinderella('Anna', 25, 37);
// let maria = new Cinderella('Maria', '30', 38);
// let oksana = new Cinderella('Oksana', 22, 35);
// let nastya = new Cinderella('Nastya', 20, 40);
// let olena = new Cinderella('Olena', 21, 36);
// let natalya = new Cinderella('Natalya', 25, 37);
// let ira = new Cinderella('Ira', 30, 39);
// let alla = new Cinderella('Alla', 28, 38);
// let anjela = new Cinderella('Anjela', 18, 35);
// let marianna = new Cinderella('Marianna', 29, 36);
//
// let girls = [anna, maria, oksana, nastya, olena, natalya, ira, alla, anjela, marianna];
// class Prince {
//     constructor(name, age, shoeSize) {
//         this.name = name;
//         this.age = age;
//         this.size = shoeSize;
//     }
// }
//
// let vasya = new Prince('Vasyl', 20, 38);
//
// for (const girl of girls) {
//     if (vasya.size === girl.size) {
//         let vasyaGirl = girl.name;
//         console.log(`Now ${vasya.name} girl is ${girl.name}`);
//         break
//     }
// }

// ==============================================
//     -створити функцію конструктор попелюшка з полями ім'я, вік, розмір ноги
// --Створити 10 попелюшок , покласти їх в масив
// --Сторити об'єкт типу "принц" за допомоги функції конструктора з полями ім'я, вік, туфелька яку він знайшов, та функцію "пошук попелюшки"
// -- функція повинна приймати масив попелюшок, та шукає ту котра йому підходить
// ==============================================

// function Cinderella(name, age, footSize) {
//         this.name = name;
//         this.age = age;
//         this.size = footSize;
// }
//
// let anna = new Cinderella('Anna', 25, 37);
// let maria = new Cinderella('Maria', '30', 38);
// let oksana = new Cinderella('Oksana', 22, 35);
// let nastya = new Cinderella('Nastya', 20, 40);
// let olena = new Cinderella('Olena', 21, 36);
// let natalya = new Cinderella('Natalya', 25, 37);
// let ira = new Cinderella('Ira', 30, 39);
// let alla = new Cinderella('Alla', 28, 38);
// let anjela = new Cinderella('Anjela', 18, 35);
// let marianna = new Cinderella('Marianna', 29, 36);
//
// let girls = [anna, maria, oksana, nastya, olena, natalya, ira, alla, anjela, marianna];
//
// function Prince (name, age, shoeSize) {
//         this.name = name;
//         this.age = age;
//         this.size = shoeSize;
//         this.searchCinderella = function (cinderellas) {
//             for (const cinderella of cinderellas) {
//                 if (this.size === cinderella.size) {
//                     console.log(`Now ${this.name} girl is ${cinderella.name}`);
//                     break
//                 }
//             }
//         }
// }
//
// let vasya = new Prince('Vasyl', 20, 38);
//
//
// vasya.searchCinderella(girls)